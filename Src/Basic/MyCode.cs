using System;
using System.Text;
using System.IO;
using System.Reflection;

//All rights reserved to Shone, author of Shone.Math (https://github.com/shonescript/Shone.Math).
namespace Shone
{
    /// <summary>
    /// Helper class for auto generating some codes
    /// </summary>
    public class MyCode
    {
        static string dir = @"C:\Hjx\Shone2020\Shone.Math\Src\AutoGenerated\";
        public static void AutoGenerate()
        {
            GenerateRefCode();
            GenerateArrayCode(false);
            GenerateArrayCode(true);
            GenerateSpanCode(false, false);
            GenerateSpanCode(false, true);
            GenerateSpanCode(true, false);
            GenerateSpanCode(true, true);
        }

        static void GenMethods(StringBuilder sb, Type t, string name)
        {
            var ts = MyType.AliaNames[t];
            if (MyReflection.Op1NameMaps.ContainsKey(name))
                sb.Append($"        public static {ts} {name}({ts} x) => {MyReflection.Op1NameMaps[name]} x;\r\n");
            else if (MyReflection.Op2NameMaps.ContainsKey(name))
                sb.Append($"        public static {ts} {name}({ts} x, {ts} y) => x {MyReflection.Op2NameMaps[name]} y;\r\n");
            else if (MyReflection.Op2bNameMaps.ContainsKey(name))
                sb.Append($"        public static bool {name}({ts} x, {ts} y) => x {MyReflection.Op2bNameMaps[name]} y;\r\n");
        }

        static void GenCode(string file, string head, Action<StringBuilder, string, Delegate> act)
        {
            var sb = new StringBuilder(1024);
            sb.Append(head);
            var mt = typeof(Math<double>);
            Console.WriteLine(mt);
            var fs = mt.GetFields(MyReflection.PublicStatic);
            foreach (var f in fs)
            {
                var name = f.Name;
                if (name.StartsWith("From")) continue;
                var o = f.GetValue(null);
                if (o is Delegate d)
                {
                    act(sb, name, d);
                }
            }
            sb.Append(@"    }
}");
            File.WriteAllText(dir + file, sb.ToString(), System.Text.Encoding.Default);
        }
        static string TStr(Type t, string name, bool inPara = false)
        {
            var ts = MyType.AliaNames.ContainsKey(t) ? MyType.AliaNames[t] : t.Name;
            return t == MyType.Double && ((inPara && name == "ToDouble") || !name.EndsWith("Double")) ? "T" : ts;
        }

        static void GenerateRefCode()
        {
            GenCode("MyRef_.cs", @"using System;

//All rights reserved to Shone, author of Shone.Math (https://github.com/shonescript/Shone.Math).
namespace Shone
{
    /// <summary>
    /// Helper class auto gerated for generic number ref T modifying extension
    /// </summary>
    public static class MyRef_
    {
", (sb, name, d) =>
            {
                var m = d.Method;
                var rt = m.ReturnType;
                var paras = m.GetParameters();
                if (name.StartsWith("To") || rt != paras[0].ParameterType) return;

                sb.Append($"        public static ref {TStr(rt, name)} {name}_<T>(this ref ");
                var n = paras.Length;
                for (int i = 0; i < n; i++)
                {
                    var p = paras[i].ParameterType;
                    if (i > 0) sb.Append(", ");
                    sb.Append($"{TStr(p, name, true)} a{i + 1}");
                }
                sb.Append($") where T : struct {{ a1 = Math<T>.{name}(");
                for (int i = 0; i < n; i++)
                {
                    if (i > 0) sb.Append(", ");
                    sb.Append($"a{i + 1}");
                }
                sb.Append("); return ref a1;}\r\n");
            });
        }

        static void GenerateArrayCode(bool bModify)
        {
            var tname = "MyArray";
            if (bModify) tname += "_";
            GenCode(tname + ".cs", @"using System;

//All rights reserved to Shone, author of Shone.Math (https://github.com/shonescript/Shone.Math).
namespace Shone
{
    /// <summary>
    /// Helper class auto gerated for generic array T[] " + (bModify ? "modifying " : " ") + @"extension
    /// </summary>
    public static partial class " + tname + @"
    {
", (sb, name, d) =>
            {
                var method = d.Method;
                AddArrayMethod(sb, name, method, bModify, false);
                AddArrayMethod(sb, name, method, bModify, true);
            });
        }
        static void AddArrayMethod(StringBuilder sb, string name, MethodInfo m, bool bModify, bool bSpecial)
        {
            var rt = m.ReturnType;
            var paras = m.GetParameters();
            if (bModify && (name.StartsWith("To") || rt != paras[0].ParameterType)) return;
            var n = paras.Length;
            if (bSpecial && n != 2) return;
            sb.Append($"        public static {TStr(rt, name)}[] {(bModify ? name + "_" : name)}<T>(this ");
            for (int i = 0; i < n; i++)
            {
                var p = paras[i].ParameterType;
                var s = "[]";
                if (i > 0)
                {
                    sb.Append(", ");
                    if (bSpecial) s = "";
                }
                sb.Append($"{TStr(p, name, true)}{s} a{i + 1}");
            }
            sb.Append($") => Func{(bModify ? "_" : "")}(");
            for (int i = 0; i < n; i++)
            {
                sb.Append($"a{i + 1}");
                sb.Append(", ");
            }
            sb.Append($"Math<T>.{name});\r\n");
        }

        static void GenerateSpanCode(bool bMemory, bool bRead)
        {
            var tname = (bRead ? "ReadOnly" : "") + (bMemory ? "Memory" : "Span");
            var mname = "My" + tname;
            if (!bRead) mname += "_";
            GenCode(tname + ".cs", @"using System;

//All rights reserved to Shone, author of Shone.Math (https://github.com/shonescript/Shone.Math).
namespace Shone
{
    /// <summary>
    /// Helper class auto gerated for generic " + tname + (bRead ? " " : "modifying ") + @"extension
    /// </summary>
    public static partial class " + mname + @"
    {
", (sb, name, d) =>
            {
                var method = d.Method;
                AddSpanMethod(sb, name, method, tname, bRead, false);
                AddSpanMethod(sb, name, method, tname, bRead, true);
            });
        }
        static void AddSpanMethod(StringBuilder sb, string name, MethodInfo m, string tname, bool bRead, bool bSpecial)
        {
            var rt = m.ReturnType;
            var paras = m.GetParameters();
            if (name.StartsWith("To") || rt != paras[0].ParameterType) return;
            var n = paras.Length;
            if (bSpecial && n != 2) return;
            if (bRead)
                sb.Append($"        public static {TStr(rt, name)}[] {name}<T>(this ");
            else
                sb.Append($"        public static {tname}<{TStr(rt, name)}> {name + "_"}<T>(this ");
            for (int i = 0; i < n; i++)
            {
                var p = paras[i].ParameterType;
                var b = i > 0;
                if (b) sb.Append(", ");
                if (bSpecial && b)
                    sb.Append($"{TStr(p, name, true)} a{i + 1}");
                else
                    sb.Append($"{tname}<{TStr(p, name, true)}> a{i + 1}");
            }
            sb.Append($") => Func{(bRead ? "" : "_")}(");
            for (int i = 0; i < n; i++)
            {
                sb.Append($"a{i + 1}");
                sb.Append(", ");
            }
            sb.Append($"Math<T>.{name});\r\n");
        }
    }
}
